
;; bytecode instructions
(define *opcodes*
  '((LOAD-NIL       . 1)
    (LOAD-FALSE     . 2)
    (LOAD-TRUE      . 3)
    (LOAD-ZERO      . 4)
    (LOAD-ONE       . 5)
    (LOAD-FIXNUM    . 6)
    (LOAD-CHAR      . 7)
    (INC            . 8)
    (DEC            . 9)
    (FIXNUM-TO-CHAR . 10)
    (CHAR-TO-FIXNUM . 11)
    (NULL-P         . 12)
    (ZERO-P         . 13)
    (NOT            . 14)
    (BOOL-P         . 15)
    (CHAR-P         . 16)
    (FIXNUM-P       . 17)
    (PUSH           . 18)
    (POP            . 19)
    (PLUS           . 20)
    (MINUS          . 21)
    (MULT           . 22)
    (LOAD0          . 23)
    (LOAD1          . 24)
    (LOAD2          . 25)
    (LOAD3          . 26)
    (LOAD           . 27)
    (SET-FP         . 28)
    (SAVE-FP        . 29)
    (REST-FP        . 30)))

(define (make-compiler-state)
  (vector
   0                          ;; Index of next instruction
   (make-vector 16 0)))       ;; code vector

(define (write-code-vector cs)
  (write (vector-ref cs 1)))

(define (code-capacity cs)
  (vector-length (vector-ref cs 1)))

(define (code-size cs)
  (vector-ref cs 0))

(define (extend-code-vector! cs)
  (let* ((len (vector-length (vector-ref cs 1)))
         (new-len (round (/ (* 3 len) 2)))
         (new-vec (make-vector new-len 0)))
    (let loop ((i 0))
      (if (= i len)
          (vector-set! cs 1 new-vec)
          (begin
            (vector-set! new-vec i (vector-ref (vector-ref cs 1) i))
            (loop (+ i 1)))))))

(define (add-to-code! cs byte)
  (let ((i (code-size cs)))
    (and (= i (code-capacity cs))
         (extend-code-vector! cs))
    (vector-set! cs 0 (+ i 1))
    (vector-set! (vector-ref cs 1) i byte)))

(define (insert-into-code! cs i byte)
  (vector-set! (vector-ref cs 1) i byte))

(define (instr cs i . args)
  (add-to-code! cs (cdr (assv i *opcodes*)))
  (or (null? args)
      (for-each (lambda (x)
                  (add-to-code! cs x))
                args)))

(define (immediate? x)
  (or (char? x)
      (boolean? x)
      (integer? x)
      (null? x)))

(define (emit-fixnum cs x)
  (let* ((b4 (quotient  x  16777216))
         (x4 (remainder x  16777216))
         (b3 (quotient  x4 65536))
         (x3 (remainder x4 65536))
         (b2 (quotient  x3 256))
         (b1 (remainder x3 256)))
    (add-to-code! cs b1)
    (add-to-code! cs b2)
    (add-to-code! cs b3)
    (add-to-code! cs b4)))
  
;; emit code for immediate values
(define (emit-immediate cs x)
  (cond
   ((null? x)
    (instr cs 'LOAD-NIL))
   ((boolean? x)
    (if x
        (instr cs 'LOAD-TRUE)
        (instr cs 'LOAD-FALSE)))
   ((char? x)
    (instr cs 'LOAD-CHAR (char->integer x)))
   ((integer? x)
    (case x
      ((0)
       (instr cs 'LOAD-ZERO))
      ((1)
       (instr cs 'LOAD-ONE))
      (else
       (instr cs 'LOAD-FIXNUM)
       (emit-fixnum cs x))))
   (else
    (error "unknown immediate"))))

(define (unary-primm cs op exp env)
  (compile-exp cs (cadr exp) env)
  (instr cs op))

(define (binary-primm cs op exp env)
  (compile-exp cs (caddr exp) env)
  (instr cs 'PUSH)
  (compile-exp cs (cadr exp) env)
  (instr cs op))

(define (lookup var env ret)
  (if (null? env)
      (ret #f #f)
      (let loop ((i 0)
                 (j 0)
                 (sec (car env))
                 (env (cdr env)))
        (if (null? sec)
            (if (null? env)
                (ret #f #f)
                (loop 0 (+ j 1) (car env) (cdr env)))
            (let ((sym (car sec)))
              (if (eq? var sym)
                  (ret i j)
                  (loop (+ i 1) j (cdr sec) env)))))))

(define (compile-seq cs exps env)
  (if (null? exps)
      (instr cs 'LOAD-NIL)
      (for-each (lambda (x)
                  (compile-exp cs x env))
                exps)))

(define (compile-let cs vars args body env)
  (instr cs 'SAVE-FP)
  (let loop ((new-env '())
             (vars vars)
             (args args))
    (if (null? vars)
        (let ((len (length new-env)))
          (instr cs 'SET-FP)
          (emit-immediate cs len)
          (instr cs 'PUSH)
          (compile-seq cs body (cons new-env env))
          (instr cs 'POP)
          (instr cs 'REST-FP))
        (let ((var (car vars))
              (exp (car args)))
          (compile-exp cs exp env)
          (instr cs 'PUSH)
          (loop (cons var new-env) (cdr vars) (cdr args))))))

(define (compile-exp cs x env)
  (if (pair? x)
      (case (car x)
        ((add1)
         (unary-primm cs 'INC x env))
        ((sub1)
         (unary-primm cs 'DEC x env))
        ((char->integer)
         (unary-primm cs 'CHAR-TO-FIXNUM x env))
        ((integer->char)
         (unary-primm cs 'FIXNUM-TO-CHAR x env))
        ((null?)
         (unary-primm cs 'NULL-P x env))
        ((zero?)
         (unary-primm cs 'ZERO-P x env))
        ((not)
         (unary-primm cs 'NOT x env))
        ((boolean?)
         (unary-primm cs 'BOOL-P x env))
        ((char?)
         (unary-primm cs 'CHAR-P x env))
        ((integer?)
         (unary-primm cs 'FIXNUM-P x env))
        ((+)
         (binary-primm cs 'PLUS x env))
        ((-)
         (binary-primm cs 'MINUS x env))
        ((*)
         (binary-primm cs 'MULT x env))
        ((begin)
         (compile-seq cs (cdr x) env))
        ((let)
         (let ((bindings (cadr x)))
           (let ((vars (map car  bindings))
                 (args (map cadr bindings)))
             (compile-let cs vars args (cddr x) env))))
        (else
         (let ((op (car x)))
           (if (and (pair? op)
                    (eq? (car op) 'lambda))
               (compile-let cs (cadr op) (cdr x) (cddr op) env)
               (error "Expression not yet supported")))))
      (cond
       ((immediate? x)
        (emit-immediate cs x))
       ((symbol? x)
        (let ((cont (lambda (i j)
                      (if i
                          (if (zero? j)
                              (case i
                                ((0)
                                 (instr cs 'LOAD0))
                                ((1)
                                 (instr cs 'LOAD1))
                                ((2)
                                 (instr cs 'LOAD2))
                                ((3)
                                 (instr cs 'LOAD3))
                                (else
                                 (instr cs 'LOAD)
                                 (emit-fixnum cs i)
                                 (emit-fixnum cs 0)))
                              (begin
                                (instr cs 'LOAD)
                                (emit-fixnum cs i)
                                (emit-fixnum cs j)))
                          (error "Unknown binding!")))))
          (lookup x env cont)))
       (else
        (error "Cannot compile atom")))))

(define (compile cs* x)
  (let ((cs (or cs* (make-compiler-state))))
    (compile-exp cs x '())
    (write-code-vector cs)))

(define (compile-to-file file x)
  (with-output-to-file file
    (lambda ()
      (compile #f x))))

