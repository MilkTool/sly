
;; bytecode instructions
(define *opcodes*
  '((LOAD-NIL       . 1)
    (LOAD-FALSE     . 2)
    (LOAD-TRUE      . 3)
    (LOAD-ZERO      . 4)
    (LOAD-ONE       . 5)
    (LOAD-FIXNUM    . 6)
    (LOAD-CHAR      . 7)
    (INC            . 8)
    (DEC            . 9)
    (FIXNUM-TO-CHAR . 10)
    (CHAR-TO-FIXNUM . 11)
    (NULL-P         . 12)
    (ZERO-P         . 13)
    (NOT            . 14)
    (BOOL-P         . 15)
    (CHAR-P         . 16)
    (FIXNUM-P       . 17)
    (PUSH           . 18)
    (POP            . 19)
    (PLUS           . 20)
    (MINUS          . 21)
    (MULT           . 22)))

(define (instr i . args)
  (display " ")
  (display (cdr (assv i *opcodes*)))
  (or (null? args)
      (for-each (lambda (x)
                  (display " ")
                  (display x))
                args)))

(define (immediate? x)
  (or (char? x)
      (boolean? x)
      (integer? x)
      (null? x)))

;; emit code for immediate values
(define (emit-immediate x)
  (cond
   ((null? x)
    (instr 'LOAD-NIL))
   ((boolean? x)
    (if x
        (instr 'LOAD-TRUE)
        (instr 'LOAD-FALSE)))
   ((char? x)
    (instr 'LOAD-CHAR (char->integer x)))
   ((integer? x)
    (case x
      ((0)
       (instr 'LOAD-ZERO))
      ((1)
       (instr 'LOAD-ONE))
      (else
       (let* ((b4 (quotient  x  16777216))
              (x4 (remainder x  16777216))
              (b3 (quotient  x4 65536))
              (x3 (remainder x4 65536))
              (b2 (quotient  x3 256))
              (b1 (remainder x3 256)))
         (instr 'LOAD-FIXNUM b1 b2 b3 b4)))))
   (else
    (error "unknown immediate"))))

(define primitive-call?
  (let ((primitives '((add1 . 1)
                      (sub1 . 1)
                      (char->integer . 1)
                      (integer->char . 1)
                      (null? . 1)
                      (zero? . 1)
                      (not . 1)
                      (boolean? . 1)
                      (char? . 1)
                      (integer? . 1)
                      (+ . 2)
                      (- . 2)
                      (* . 2))))
    (lambda (x)
      (and (pair? x)
           (assq (car x) primitives)))))

(define (unary-primm op exp)
  (compile-exp (cadr exp))
  (instr op))

(define (binary-primm op exp)
  (compile-exp (caddr exp))
  (instr 'PUSH)
  (compile-exp (cadr exp))
  (instr op))

(define (compile-exp x)
  (cond
   ((immediate? x)
    (emit-immediate x))
   ((primitive-call? x)
    (case (car x)
      ((add1)
       (unary-primm 'INC x))
      ((sub1)
       (unary-primm 'DEC x))
      ((char->integer)
       (unary-primm 'CHAR-TO-FIXNUM x))
      ((integer->char)
       (unary-primm 'FIXNUM-TO-CHAR x))
      ((null?)
       (unary-primm 'NULL-P x))
      ((zero?)
       (unary-primm 'ZERO-P x))
      ((not)
       (unary-primm 'NOT x))
      ((boolean?)
       (unary-primm 'BOOL-P x))
      ((char?)
       (unary-primm 'CHAR-P x))
      ((integer?)
       (unary-primm 'FIXNUM-P x))
      ((+)
       (binary-primm 'PLUS x))
      ((-)
       (binary-primm 'MINUS x))
      ((*)
       (binary-primm 'MULT x))))
   (else
    (error "this expression is not yet supported"))))

(define (compile x)
  (display "(")
  (compile-exp x)
  (display " )")
  (newline))

(define (compile-to-file file x)
  (with-output-to-file file
    (lambda ()
      (compile x))))

