
;; bytecode instructions
(define *opcodes*
  '((LOAD-NIL       . 1)
    (LOAD-FALSE     . 2)
    (LOAD-TRUE      . 3)
    (LOAD-ZERO      . 4)
    (LOAD-ONE       . 5)
    (LOAD-FIXNUM    . 6)
    (LOAD-CHAR      . 7)
    (INC            . 8)
    (DEC            . 9)
    (FIXNUM-TO-CHAR . 10)
    (CHAR-TO-FIXNUM . 11)
    (NULL-P         . 12)
    (ZERO-P         . 13)
    (NOT            . 14)
    (BOOL-P         . 15)
    (CHAR-P         . 16)
    (FIXNUM-P       . 17)
    (PUSH           . 18)
    (POP            . 19)
    (PLUS           . 20)
    (MINUS          . 21)
    (MULT           . 22)
    (LOAD0          . 23)
    (LOAD1          . 24)
    (LOAD2          . 25)
    (LOAD3          . 26)
    (LOAD           . 27)
    (SET-FP         . 28)
    (SAVE-FP        . 29)
    (REST-FP        . 30)))

(define (instr i . args)
  (display " ")
  (display (cdr (assv i *opcodes*)))
  (or (null? args)
      (for-each (lambda (x)
                  (display " ")
                  (display x))
                args)))

(define (immediate? x)
  (or (char? x)
      (boolean? x)
      (integer? x)
      (null? x)))

(define (emit-fixnum x)
  (let* ((b4 (quotient  x  16777216))
         (x4 (remainder x  16777216))
         (b3 (quotient  x4 65536))
         (x3 (remainder x4 65536))
         (b2 (quotient  x3 256))
         (b1 (remainder x3 256)))
    (display (list " " b1 " " b2 " " b3 " " b4))))
  
;; emit code for immediate values
(define (emit-immediate x)
  (cond
   ((null? x)
    (instr 'LOAD-NIL))
   ((boolean? x)
    (if x
        (instr 'LOAD-TRUE)
        (instr 'LOAD-FALSE)))
   ((char? x)
    (instr 'LOAD-CHAR (char->integer x)))
   ((integer? x)
    (case x
      ((0)
       (instr 'LOAD-ZERO))
      ((1)
       (instr 'LOAD-ONE))
      (else
       (instr 'LOAD-FIXNUM)
       (emit-fixnum x))))
   (else
    (error "unknown immediate"))))

(define (unary-primm op exp env)
  (compile-exp (cadr exp) env)
  (instr op))

(define (binary-primm op exp env)
  (compile-exp (caddr exp) env)
  (instr 'PUSH)
  (compile-exp (cadr exp) env)
  (instr op))

(define (lookup var env ret)
  (if (null? env)
      (ret #f #f)
      (let loop ((i 0)
                 (j 0)
                 (sec (car env))
                 (env (cdr env)))
        (if (null? sec)
            (if (null? env)
                (ret #f #f)
                (loop 0 (+ j 1) (car env) (cdr env)))
            (let ((sym (car sec)))
              (if (eq? var sym)
                  (ret i j)
                  (loop (+ i 1) j (cdr sec) env)))))))

(define (compile-seq exps env)
  (if (null? exps)
      (instr 'LOAD-NIL)
      (for-each (lambda (x)
                  (compile-exp x env))
                exps)))

(define (compile-let bindings body env)
  (instr 'SAVE-FP)
  (let loop ((new-env '())
             (bindings bindings))
    (if (null? bindings)
        (begin
          (instr 'SET-FP)
          (compile-seq body (cons new-env env))
          (instr 'POP)
          (emit-fixnum (length new-env))
          (instr 'REST-FP))
        (let ((var (caar bindings))
              (exp (cadar bindings)))
          (compile-exp exp env)
          (instr 'PUSH)
          (loop (cons var new-env) (cdr bindings))))))

(define (compile-exp x env)
  (if (pair? x)
      (case (car x)
        ((add1)
         (unary-primm 'INC x env))
        ((sub1)
         (unary-primm 'DEC x env))
        ((char->integer)
         (unary-primm 'CHAR-TO-FIXNUM x env))
        ((integer->char)
         (unary-primm 'FIXNUM-TO-CHAR x env))
        ((null?)
         (unary-primm 'NULL-P x env))
        ((zero?)
         (unary-primm 'ZERO-P x env))
        ((not)
         (unary-primm 'NOT x env))
        ((boolean?)
         (unary-primm 'BOOL-P x env))
        ((char?)
         (unary-primm 'CHAR-P x env))
        ((integer?)
         (unary-primm 'FIXNUM-P x env))
        ((+)
         (binary-primm 'PLUS x env))
        ((-)
         (binary-primm 'MINUS x env))
        ((*)
         (binary-primm 'MULT x env))
        ((begin)
         (compile-seq (cdr x) env))
        ((let)
         (compile-let (cadr x) (cddr x) env))
        (else
         (error "Expression not yet supported")))
      (cond
       ((immediate? x)
        (emit-immediate x))
       ((symbol? x)
        (let ((cont (lambda (i j)
                      (if i
                          (if (zero? j)
                              (case i
                                ((0)
                                 (instr 'LOAD0))
                                ((1)
                                 (instr' LOAD1))
                                ((2)
                                 (instr 'LOAD2))
                                ((3)
                                 (instr 'LOAD3))
                                (else
                                 (instr 'LOAD)
                                 (emit-fixnum i)
                                 (emit-fixnum 0)))
                              (begin
                                (instr 'LOAD)
                                (emit-fixnum i)
                                (emit-fixnum j)))
                          (error "Unknown binding!")))))
          (lookup x env cont)))
       (else
        (error "Cannot compile atom")))))

(define (compile x)
  (display "(")
  (compile-exp x '())
  (display " )")
  (newline))

(define (compile-to-file file x)
  (with-output-to-file file
    (lambda ()
      (compile x))))

